To debug our binaries, we will be using a well-known debugger for Linux programs called [GNU Debugger](https://www.gnu.org/software/gdb/) (`GDB`). There are other similar debuggers for Linux, like [Radare](https://www.radare.org/r/) and [Hopper](https://www.hopperapp.com/), and for Windows, like [Immunity Debugger](https://www.immunityinc.com/products/debugger/) and [WinGDB](http://wingdb.com/). There are also powerful debuggers available for many platforms, like [IDA Pro](https://www.hex-rays.com/products/ida/) and [EDB](https://github.com/eteran/edb-debugger). In this module, we will be using GDB.
___

**Contents:**

- [[#Installation|Installation]]
- [[#Getting Started|Getting Started]]
- [[#Info|Info]]
		- [[#Functions|Functions]]
		- [[#Variables|Variables]]
- [[#Disassemble|Disassemble]]
- [[#Debugging with GDB|Debugging with GDB]]
	- [[#Debugging with GDB#Break|Break]]
	- [[#Debugging with GDB#Examine|Examine]]
		- [[#Instructions|Instructions]]
		- [[#Strings|Strings]]
		- [[#Addresses|Addresses]]
	- [[#Debugging with GDB#Step|Step]]
		- [[#Step Instruction|Step Instruction]]
		- [[#Step Count|Step Count]]
		- [[#Step|Step]]
	- [[#Debugging with GDB#Modify|Modify]]
		- [[#Addresses|Addresses]]
		- [[#Registers|Registers]]



## Installation

``` bash
sudo apt update && sudo apt install gdb
```

One of the great features of `GDB` is its support for third-party plugins. An excellent plugin that is well maintained and has good documentation is [GEF](https://github.com/hugsy/gef). GEF is a free and open-source GDB plugin that is built precisely for reverse engineering and binary exploitation. This fact makes it a great tool to learn.

To add GEF to GDB, we can use the following commands:
``` bash
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py && echo source ~/.gdbinit-gef.py >> ~/.gdbinit
```
___

## Getting Started

``` bash
gdb -q ./helloWorld
```
GEF is loaded when GDB is run. If you ever run into any issues with `GEF`, you can consult with the [GEF Documentation](https://hugsy.github.io/gef/), and you will likely find a solution.

Going forward, we will frequently be assembling and linking our assembly code and then running it with `gdb`. To do so quickly, we can use the `assembler.sh` script we wrote in the previous section with the `-g` flag. It will assemble and link the code, and then run it with `gdb`, as follows:
```
./assembler.sh helloWorld.s -g
```
___

## Info
Once `GDB` is started, we can use the `info` command to view general information about the program.

>Tip: If we want to understand how any command runs within `GDB`, we can use the `help CMD` command to get its documentation. For example, we can try executing `help info`

#### Functions
To start, we will use the `info` command to check which `functions` are defined within the binary. As we can see, we found our main `_start` function:
```
gef➤  info functions

All defined functions:

Non-debugging symbols:
0x0000000000401000  _start
```

#### Variables
`info variables` shows all available variables. We find the message, along with some other default variables that define mem segments.
``` 
gef➤  info variables

All defined variables:

Non-debugging symbols:
0x0000000000402000  message
0x0000000000402012  __bss_start
0x0000000000402012  _edata
0x0000000000402018  _end
```
___

## Disassemble

To view the instructions within a specific function, we can use the `disassemble` or `disas` command along with the function name, as follows:
```shell-session
gef➤  disas _start

Dump of assembler code for function _start:
   0x0000000000401000 <+0>:	mov    eax,0x1
   0x0000000000401005 <+5>:	mov    edi,0x1
   0x000000000040100a <+10>:	movabs rsi,0x402000
   0x0000000000401014 <+20>:	mov    edx,0x12
   0x0000000000401019 <+25>:	syscall
   0x000000000040101b <+27>:	mov    eax,0x3c
   0x0000000000401020 <+32>:	mov    edi,0x0
   0x0000000000401025 <+37>:	syscall
End of assembler dump.
```
As we can see, the output we got closely resembles our assembly code and the disassembly output we got from `objdump` in the previous section. We need to focus on the main thing from this disassembly: the memory addresses for each instruction and operands (i.e., arguments).

> Having the memory address is critical for examining the variables/operands and setting breakpoints for a certain instruction.

>Note: You may notice through debugging that some memory addresses are in the form of `0x00000000004xxxxx`, rather than their raw address in memory `0xffffffffaa8a25ff`. This is due to `$rip-relative addressing` in Position-Independent Executables `PIE`, in which the memory addresses are used relative to their distance from the instruction pointer `$rip` within the program's own Virtual RAM, rather than using raw memory addresses. This feature may be disabled to reduce the risk of binary exploitation.
___

# Debugging with GDB

Debugging consists mainly of four steps:

1. Break
2. Examine
3. Step
4. Modify

## Break

 - We can set a breakpoint at a specific address or for a particular function. 
	 - To set a breakpoint, we can use the `break` or `b` command along with the address or function name we want to break at. 
- For example, to follow all instructions run by our program, let's break at the `_start` function, as follows:
```shell-session
gef➤  b _start

Breakpoint 1 at 0x401000
```

Then to start the program, use `run` or `r`:
```
gef➤  b _start
Breakpoint 1 at 0x401000
gef➤  r
Starting program: ./helloWorld 
Breakpoint 1, 0x0000000000401000 in _start ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0               
$rbx   : 0x0               
$rcx   : 0x0               
$rdx   : 0x0               
$rsp   : 0x00007fffffffe310  →  0x0000000000000001
$rbp   : 0x0               
$rsi   : 0x0               
$rdi   : 0x0               
$rip   : 0x0000000000401000  →  <_start+0> mov eax, 0x1
...SNIP...
───────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe310│+0x0000: 0x0000000000000001	 ← $rsp
0x00007fffffffe318│+0x0008: 0x00007fffffffe5a0  →  "./helloWorld"
...SNIP...
─────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ffa                  add    BYTE PTR [rax], al
     0x400ffc                  add    BYTE PTR [rax], al
     0x400ffe                  add    BYTE PTR [rax], al
 →   0x401000 <_start+0>       mov    eax, 0x1
     0x401005 <_start+5>       mov    edi, 0x1
     0x40100a <_start+10>      movabs rsi, 0x402000
     0x401014 <_start+20>      mov    edx, 0x12
     0x401019 <_start+25>      syscall 
     0x40101b <_start+27>      mov    eax, 0x3c
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "helloWorld", stopped 0x401000 in _start (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x401000 → _start()
─────────────────────────────
```

- To set a breakpoint at an address, like `_start+10`, use either `b *_start+10` or `b *0x40100a`.
	- The `*` tells `GDB` to break at the instruction stored in `0x40100a`.

>Note: Once the program is running, if we set another breakpoint, like `b *0x401005`, in order to continue to that breakpoint, we should use the `continue` or `c` command. If we use `run` or `r` again, it will run the program from the start. This can be useful to skip loops, as we will see later in the module.
___

## Examine

- To manually examine any of the addresses or registers or examine any other, we can use the `x` command in the format of `x/FMT ADDRESS`, as `help x` would tell us. 
	- The `ADDRESS` is the address or register we want to examine, while `FMT` is the examine format. 
	- The examine format `FMT` can have three parts:
![[2023-07-10 12_29_28-Hack The Box - Academy.png]]

#### Instructions

- For example, if we wanted to examine the next four instructions in line, we will have to examine the `$rip` register (which holds the address of the next instruction), and use:
	- `4` for the `count`, 
	- `i` for the `format`, and 
	- `g` for the `size` (for 8-bytes or 64-bits). 
- So, the final examine command would be `x/4ig $rip`.

#### Strings

We know that our `message` variable is stored at the `.data` section on address `0x402000` from our previous disassembly. We also see the upcoming command `movabs rsi, 0x402000`, so we may want to examine what is being moved from `0x402000`.

In this case, we will not put anything for the `Count`, as we only want one address (1 is the default), and will use `s` as the format to get it in a string format rather than in hex:
```shell-session
gef➤  x/s 0x402000

0x402000:	"Hello HTB Academy!"
```

>Note: if we don't specify the `Size` or `Format`, it will default to the last one we used.

#### Addresses

The most common format of examining is hex `x`. We often need to examine addresses and registers containing hex data, such as memory addresses, instructions, or binary data. Let us examine the same previous instruction, but in `hex` format, to see how it looks:
```shell-session
gef➤  x/wx 0x401000

0x401000 <_start>:	0x000001b8
```

We see instead of `mov eax,0x1`, we get `0x000001b8`, which is the hex representation of the `mov eax,0x1` machine code in little-endian formatting.
	This is read as: `b8 01 00 00`.

Also,  at any point we can use the `registers` command to print out the current value of all registers.
___

## Step

The third step of debugging is `stepping` through the program one instruction or line of code at a time. As we can see, we are currently at the very first instruction in our `helloWorld` program:
```
──────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400ffe                  add    BYTE PTR [rax], al
 →   0x401000 <_start+0>       mov    eax, 0x1
     0x401005 <_start+5>       mov    edi, 0x1
```

>Note: the instruction shown with the `->` symbol is where we are at, and it has not yet been processed.

To move through the program we can use `stepi` and `step`.

#### Step Instruction

The `stepi` or `si` command will step through the assembly instructions one by one, which is the smallest level of steps possible while debugging.

#### Step Count

Similarly to examine, we can repeat the `si` command by adding a number after it. For example, if we wanted to move 3 steps to reach the `syscall` instruction, we can do so as follows: `si 3`

> Tip: You can hit the `return`/`enter` empty in order to repeat the last command. Try hitting it at this stage, and you should make another 3 steps, and break at the other `syscall` instruction.

#### Step

The `step` or `s` command, on the other hand, will continue until the following line of code is reached or until it exits from the current function. If we run an assembly code, it will break when we exit the current function `_start`.

If there's a call to another function within this function, it'll break at the beginning of that function

>Note: There's also the `next` or `n` command, which will also continue until the next line, but will skip any functions called in the same line of code, instead of breaking at them like `step`. There's also the `nexti` or `ni`, which is similar to `si`, but skips functions calls, as we will see later on in the module.
___

## Modify

#### Addresses

To modify values in GDB, we can use the `set` command. However, we will utilize the `patch` command in `GEF` to make this step much easier.
```shell-session
gef➤  help patch

Write specified values to the specified address.
Syntax: patch (qword|dword|word|byte) LOCATION VALUES
patch string LOCATION "double-escaped string"
...SNIP...
```

We have to provide the `type/size` of the new value, the `location` to be stored, and the `value` we want to use. So, let's try changing the string stored in the `.data` section (at address `0x402000` as we saw earlier) to the string `Patched!\n`.

We will break at the first `syscall` at `0x401019`, and then do the patch, as follows:

```shell-session
gef➤  break *0x401019

Breakpoint 1 at 0x401019
gef➤  r
gef➤  patch string 0x402000 "Patched!\\x0a"
gef➤  c

Continuing.
Patched!
 Academy!
```

Notice how we used `\x0a` for adding a new line after our string.

#### Registers

We also note that we did not replace the entire string. This is because we only modified the characters up to the length of our string and left the remainder of the old string. Finally, the `printf` function specified a length of `0x12` of bytes to be printed.

To fix this, let's modify the value stored in `$rdx` to the length of our string, which is `0x9`. We will only patch a size of one byte. We will go into details of how `syscall` works later in the module. Let us demonstrate using `set` to modify `$rdx`, as follows:
```shell-session
gef➤  break *0x401019

Breakpoint 1 at 0x401019
gef➤  r
gef➤  patch string 0x402000 "Patched!\\x0a"
gef➤  set $rdx=0x9
gef➤  c

Continuing.
Patched!
```
