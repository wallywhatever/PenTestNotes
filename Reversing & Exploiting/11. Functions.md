## Functions Calling Convention

Functions are more complex than procedures and should be expected to use the stack and all registers fully. Because of this functions have a Calling Convention to properly set up before being called.

The four main things to consider before calling a function:
1. Save registers on the stack (Caller Saved)
2. Pass Function Arguments (like syscalls)
3. Fix Stack Alignmentt
4. Get function's return value (in `rax`)

This is similar to calling a syscall except we don't have to store the syscall number in rax but we do have to worry about stack alignment.

## Writing Functions

The above points are from a caller point of view. When writing a function, there are different considerations:
1. Saving callee saved registers (`rbx` and `rbp`)
2. Get arguments from registers
3. Align the stack
4. Return value in `rax`

## Using External Functions

We want to print the current Fibonacci number at each iteration of the `loopFib` loop. Previously, we could not use a `write` syscall since it only accepts `ASCII` characters. We would have had to convert our Fibonacci number to `ASCII`, which is a bit complicated.

Luckily, there are external functions we can use to print the current number without having to convert it. The `libc` library of functions used for `C` programs provides many functionalities that we can utilize without rewriting everything from scratch. The `printf` function in `libc` accepts the printing format, so we can pass it the current Fibonacci number and tell it to print it as an integer, and it'll do the conversion automatically. Before we can use a function from `libc`, we have to import it first and then specify the `libc` library for dynamic linking when linking our code with `ld`.

## Importing `libc` Functions

To import an external `libc` function, use `extern` at the beginning of the code.
```nasm
global _start
extern printf
```

Once this is done, we can call the `printf` function.

## Saving Registers

Let's define a new procedure, `printFib`, to hold our function call instructions. The very first step is to save to the stack any registers we are using, which are `rax` and `rbx`, as follows:
```nasm
printFib:
    push rax        ; push registers to stack
    push rbx
    ; function call
    pop rbx         ; restore registers from stack
    pop rax
    ret
```

So, we can proceed with the second point, and pass the required arguments to `printf`.

## Function Arguments

Function arguments are passed like [[09. Syscalls|syscall]] arguments. We can find out what arguments are accepted for `printf` by using `man -s 3` for libray functions manual.
```bash
$ man -s 3 printf

...SNIP...
       int printf(const char *format, ...);
```

As we can see, the function takes a pointer to the print format (shown with a `*`), and then the string(s) to be printed.

First, we can create a variable that contains the output format to pass it as the first argument. The `printf` man page also details various print formats. We want to print an integer, so we can use the `%d` format, as follows:
```nasm
global  _start
extern  printf

section .data
    message db "Fibonacci Sequence:", 0x0a
    outFormat db  "%d", 0x0a, 0x00
```

>Note: We ended the format with a null character `0x00`, as this is the string terminator in `printf`, and we must terminate any string with it.

This can be our first argument, and `rbx` as our second argument, which `printf` will place as `%d`. So, let's move both arguments to their respective registers, as follows:
```nasm
printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    <Call>
    pop rbx             ; restore registers from stack
    pop rax
    ret
```


## Stack Alignment

Whenever we want to make a `call` to a function, we must ensure that the `Top Stack Pointer (rsp)` is aligned by the `16-byte` boundary from the `_start` function stack.

This means that we have to push at least 16-bytes (or a multiple of 16-bytes) to the stack before making a call to ensure functions have enough stack space to execute correctly. This requirement is mainly there for processor performance efficiency. Some functions (like in `libc`) are programed to crash if this boundary is not fixed to ensure performance efficiency. If we assemble our code and break right after the second `push`, this is what we will see:
![[2023-07-13_22-13.png]]

We see that we have four 8-bytes pushed to the stack, making a total boundary of 32-bytes. This is due to two things:

1. Each procedure `call` adds an 8-byte address to the stack, which is then removed with `ret`
2. Each `push` adds 8-bytes to the stack as well

So, we are inside `printFib` and inside `loopFib`, and have pushed `rax` and `rbx`, for a total of a 32-byte boundary. Since the boundary is a multiple of 16, `our stack is already aligned, and we don't have to fix anything.`

If we were in a case where we wanted to bring the boundary up to 16, we can subtract bytes from `rsp`, as follows:
```nasm
 sub rsp, 16
    call function
    add rsp, 16
```

This way, we are adding an extra 16-bytes to the top of the stack and then removing them after the call. If we had 8 bytes pushed, we can bring the boundary up to 16 by subtracting 8 from `rsp`.

This may be a bit confusing, but the critical thing to remember is that `we should have 16-bytes (or a multiple of 16) on top of the stack before making a call.` We can count the number of (un`pop`ed) `push` instructions and (un`ret`urned) `call` instructions, and we will get how many 8-bytes have been pushed to the stack.

## Function Call

Finally, we can issue `call printf`, and it should print the current Fibonacci number in the format we specified, as follows:
```nasm
printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    call printf         ; printf(outFormat, rbx)
    pop rbx             ; restore registers from stack
    pop rax
    ret
```

Now we should have our `printFib` procedure ready. So, we can add it to the beginning of `loopFib`, such that it prints the current Fibonacci number at the beginning of each loop:
```nasm
loopFib:
    call printFib   ; print current Fib number
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
    ret
```

Our final `fib.s` code should be as follows:
```nasm
global  _start
extern  printf

section .data
    message db "Fibonacci Sequence:", 0x0a
    outFormat db  "%d", 0x0a, 0x00

section .text
_start:
    call printMessage   ; print intro message
    call initFib        ; set initial Fib values
    call loopFib        ; calculate Fib numbers
    call Exit           ; Exit the program

printMessage:
    mov rax, 1           ; rax: syscall number 1
    mov rdi, 1          ; rdi: fd 1 for stdout
    mov rsi, message    ; rsi: pointer to message
    mov rdx, 20          ; rdx: print length of 20 bytes
    syscall             ; call write syscall to the intro message
    ret

initFib:
    xor rax, rax        ; initialize rax to 0
    xor rbx, rbx        ; initialize rbx to 0
    inc rbx             ; increment rbx to 1
    ret

printFib:
    push rax            ; push registers to stack
    push rbx
    mov rdi, outFormat  ; set 1st argument (Print Format)
    mov rsi, rbx        ; set 2nd argument (Fib Number)
    call printf         ; printf(outFormat, rbx)
    pop rbx             ; restore registers from stack
    pop rax
    ret

loopFib:
    call printFib       ; print current Fib number
    add rax, rbx        ; get the next number
    xchg rax, rbx       ; swap values
    cmp rbx, 10		    ; do rbx - 10
    js loopFib		    ; jump if result is <0
    ret

Exit:
    mov rax, 60
    mov rdi, 0
    syscall
```


## Dynamic Linker

We can now assemble our code with `nasm`. When we link our code with `ld`, we should tell it to do dynamic linking with the `libc` library. Otherwise, it would not know how to fetch the imported `printf` function. We can do so with the `-lc --dynamic-linker /lib64/ld-linux-x86-64.so.2` flags, as follows:
```shell-session
$ nasm -f elf64 fib.s &&  ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2 && ./fib

1
1
2
3
5
8
```