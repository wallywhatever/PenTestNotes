## Linux Syscall

A `syscall` is like a globally available function written in `C`, provided by the Operating System Kernel. A syscall takes the required arguments in the registers and executes the function with the provided arguments. For example, if we wanted to write something to the screen, we can use the `write` syscall, provide the string to be printed and other required arguments, and then call the syscall to issue the print.

There are many available syscalls provided by the Linux Kernel, and we can find a list of them and the `syscall number` of each one by reading the `unistd_64.h` system file:
```shell-session
wallywhatever@htb[/htb]$ cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h
#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
#define __NR_stat 4
#define __NR_fstat 5
```

The above file sets the syscall number for each syscall.

>Note: With `32-bit` x86 processors, the syscall numbers are in the `unistd_32.h` file.


## Syscall Function Arguments

To use the `write` syscall, we must first know what arguments it accepts. To find the arguments accepted by a syscall, we can use the `man -s 2` command with the syscall name from the above list:
```shell-session
wallywhatever@htb[/htb]$ man -s 2 write
...SNIP...
       ssize_t write(int fd, const void *buf, size_t count);
```

As we can see from the above output, the `write` function has the following syntax:
```c
ssize_t write(int fd, const void *buf, size_t count);
```

We see that the syscall function expects `3` arguments:

1. File Descriptor `fd` to be printed to (_usually `1` for `stdout`_)
2. The address pointer to the string to be printed
3. The length we want to print

Once we provide these arguments, we can use the syscall instruction to execute the function and print to screen.

>Tip: The `-s 2` flag specifies `syscall` man pages. We can check `man man` to see various sections for each man page.


## Syscall Calling Convention

To call a syscall, we have to:

1. Save registers to stack
2. Set its syscall number in `rax`
3. Set its arguments in the registers
4. Use the syscall assembly instruction to call it

`We usually should save any registers we use to the stack before any function call or syscall.` However, as we are running this syscall at the beginning of our program before using any registers, we don't have any values in the registers, so we should not worry about saving them.

#### Syscall Number

Let's start by moving the syscall number to the `rax` register. As we saw earlier, the `write` syscall has a number `1`, so we can start with the following command:
```nasm
mov rax, 1
```

#### Syscall Arguments

Next, we should put each of the function's arguments in its corresponding register. The `x86_64` architecture's calling convention specifies in which register each argument should be placed (e.g., first arg should be in `rdi`).
![[Pasted image 20230711211018.png]]

As we can see, we have a register for each of the first `6` arguments. Any additional arguments can be stored in the stack (though not many syscalls use more than `6` arguments.).

>Note: `rax` is also used for storing the `return value` of a syscall or a function. So, if we were expecting to get a value back from a syscall/function, it will be in `rax`.

With that, we should know our arguments and in which register we should store them. Going back to the `write` syscall function, we should pass: `fd`, `pointer`, and `length`. We can do so as follows:

1. `rdi` -> `1` (for stdout)
2. `rsi` -> `'Fibonacci Sequence:\n'` (pointer to our string)
3. `rdx` -> `20` (length of our string)

We can use `mov rcx, 'string'`. However, we can only store up to 16 characters in a register (i.e., 64 bits), so our intro string would not fit. Instead, let's create a variable with our string (as we learned in the `Assembly File Structure` section), similarly to what we did with the `Hello World` program:
```nasm
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a
```

The `message` label is a pointer to where our string will be stored in the memory. So, we can use it as our second argument. So, our final syscall code should be as follows:
```nasm
mov rax, 1       ; rax: syscall number 1
mov rdi, 1      ; rdi: fd 1 for stdout
mov rsi,message ; rsi: pointer to message
mov rdx, 20      ; rdx: print length of 20 bytes
```

>Tip: If we ever needed to create a pointer to a value stored in a register, we can simply push it to the stack, and then use the `rsp` pointer to point to it.

We may also use a dynamically calculated `length` variable by using `equ`, similarly to what we did with the `Hello World` program.


## Calling Syscall

Now that we have our syscall number and arguments in place, the only thing left is to do the syscall instruction. So, let's add a syscall instruction and add the instructions to the beginning of our `fib.s` code, which should look as follows:
```nasm
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a

section .text
_start:
    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1      ; rdi: fd 1 for stdout
    mov rsi,message ; rsi: pointer to message
    mov rdx, 20      ; rdx: print length of 20 bytes
    syscall         ; call write syscall to the intro message
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
```

Let's now assemble our code and run it, and see if our intro message gets printed:
```shell-session
wallywhatever@htb[/htb]$ ./assembler.sh fib.s

Fibonacci Sequence:
[1]    107348 segmentation fault  ./fib
```

We see that indeed our string is printed to the screen. Let's run it through `gdb`, and break at the syscall to see how all arguments are setup before we call syscall, as follows:
![[Pasted image 20230711211406.png]]

We see a couple of things that we expected:

1. Our arguments are properly set in the corresponding registers before each syscall.
2. A pointer to our message is loaded in `rsi`.

Now, we have successfully used the `write` syscall to print our intro message.


## Exit Syscall

Finally, since we have understood how syscalls work, let's go through another essential syscall used in programs: `Exit syscall`. We may have noticed that so far, whenever our program finishes executing, it exits with a `segmentation fault`, as we just saw when we ran `./fib`. This is because we are ending our program abruptly, without going through the proper procedure of exiting programs in Linux, by calling the `exit syscall` and passing an exit code.

So, let's add this to the end of our code. First, we need to find the `exit syscall` number, as follows:
```shell-session
wallywhatever@htb[/htb]$ grep exit /usr/include/x86_64-linux-gnu/asm/unistd_64.h

#define __NR_exit 60
#define __NR_exit_group 231
```

We need to use the first one, with a syscall number `60`. Next, let's see if the `exit syscall` needs any arguments:
```shell-session
wallywhatever@htb[/htb]$ man -s 2 exit

...SNIP...
void _exit(int status);
```

We see that it only needs one integer argument, `status`', which is explained to be the exit code. In Linux, whenever a program exits without any errors, it passes an exit code of `0`. Otherwise, the exit code is a different number, usually `1`. In our case, as everything went as expected, we'll pass the exit code of `0`. Our `exit syscall` code should be as follows:
```nasm
    mov rax, 60
    mov rdi, 0
    syscall
```
