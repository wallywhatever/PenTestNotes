# Loop Structure

A loop in assembly is a set of instructions that repeat for `rcx` times. Let's take the following example:
```nasm
exampleLoop:
    instruction 1
    instruction 2
    instruction 3
    instruction 4
    instruction 5
    loop exampleLoop
```

Once the assembly code reaches `exampleLoop`, it will start executing the instructions under it. We should set the number of iterations we want the loop to go through in the `rcx` register. Every time the loop reaches the `loop` instruction, it will decrease `rcx` by `1` (i.e., `dec rcx`) and jump back to the specified label, `exampleLoop` in this case. So, before we enter any loop, we should `mov` the number of loop iterations we want to the `rcx` register.

- **mov rcx, x** - Sets loop (`rcx`) counter to `x`
	- `mov rcx, 3`
- `loop` - Jumps back to the start of `loop` until the counter reaches `0`
	- `loop exampleLoop`

To demonstrate this, let's go back to our `fib.s` code:
```nasm
global  _start

section .text
_start:
    xor rax, rax
    xor rbx, rbx
    inc rbx
    add rax, rbx
```

Since any current Fibonacci number is the sum of the two numbers preceding it, we can automate this with a loop. Let's assume that the current number is stored in `rax`, so it is `Fn`, and the next number is stored in `rbx`, so it is `Fn+1`.

Starting with the last number as `0` and the current number as `1`, we can have our loop as follows:

1. Get next number with `0 + 1 = 1`
2. Move the current number to the last number (`1 in place of 0`)
3. Move the next number to the current number (`1 in place of 1`)
4. Loop

If we do this, we'll end up with `1` as the last number and `1` as the current number. If we loop again, we'll get `1` as the last number and `2` as the current number. So, let's implement this as assembly instructions. Since we can discard the last number `0` after we use it in the add, let's store the result in its place:

- `add rax, rbx`

We need to move the current number to the last number's place and move the following number to the current number. However, we have the following number in `rax` and the now old number in `rbx`, so they are swapped. 

Let's use the `xchg` instruction to swap both numbers:

- `xchg rax, rbx`

Now we can simply `loop`. However, before we enter a loop, we should set `rcx` to the count of iterations we want. Let's start with `10` iterations and add it after initializing the `rax` and `rbx` to `0` and `1`:
```nasm
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
```

Now we can define our loop as discussed above:
```nasm
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    loop loopFib
```

The final code is:
```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    loop loopFib
```

This works. It ends with `rbx` at `0x37` which is 55 in dec. We can confirm that with the `p/d $rax` command:
```shell-session
gef➤  p/d $rbx

$3 = 55
```
___

# Unconditional Branching

## JMP loopFib

The `jmp` instruction jumps the program to the label or specified location in its operand so that the program's execution is continued there. Once a program's execution is directed to another location, it will continue processing instructions from that point.

The basic `jmp` instruction is unconditional, which means that it will always jump to the specified location, regardless of the conditions.

- **jmp** - Jumps to a specified label, address, or location
	- `jmp loop`

If we rewrite our fib.s to replace `loop loopFib` with `jmp loopFib` the program will appear to work correctly. However, `jmp` does not automatically decrement the `rcx` counter so it will continue infinitely.
___

# Conditional Branching

Unlike Unconditional Branching Instructions, `Conditional Branching` instructions are only processed when a specific condition is met, based on the Destination and Source operands. A conditional jump instruction has multiple varieties as `Jcc`, where `cc` represents the Condition Code. The following are some of the main condition codes:

|**Instruction**|**Condition**|**Description**|
|---|---|---|
|`jz`|`D = 0`|Destination `equal to Zero`|
|`jnz`|`D != 0`|Destination `Not equal to Zero`|
|`js`|`D < 0`|Destination `is Negative`|
|`jns`|`D >= 0`|Destination `is Not Negative` (i.e. 0 or positive)|
|`jg`|`D > S`|Destination `Greater than` Source|
|`jge`|`D >= S`|Destination `Greater than or Equal` Source|
|`jl`|`D < S`|Destination `Less than` Source|
|`jle`|`D <= S`|Destination `Less than or Equal` Source|

There are many other similar conditions that we can utilize as well. For a complete list of conditions, we can refer to the latest Intel [x86_64 manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=585), in the `Jcc-Jump if Condition Is Met` section. Conditional instructions are not restricted to `jmp` instructions only but are also used with other assembly instructions for conditional use as well, like the `CMOVcc` and `SETcc` instructions.

For example, if we wanted to perform a `mov rax, rbx` instruction, but only if the condition is `= 0`, then we can use the `CMOVcc` or `conditional mov` instruction, such as `cmovz rax, rbx` instruction. Similarly, if we wanted to move if the condition is `<`, then we can use the `cmovl rax, rbx` instruction, and so on for other conditions. The same applies to the `set` instruction, which sets the operand's byte to `1` if the condition is met or `0` otherwise. An example of this is `setz rax`.


## RFLAGS Register

The `RFLAGS` register consists of 64-bits like any other register. However, this register does not hold values but holds flag bits instead. Each bit 'or set of bits' turns to `1` or `0` depending on the value of the last instruction.

**Arithmetic instructions set the necessary 'RFLAG' bits depending on their outcome.**

For example, if a `dec` instruction resulted in a `0`, then bit `#6`, the Zero Flag `ZF`, turns to `1`. Likewise, whenever the bit `#6` is `0`, it means that the Zero Flag is off. Similarly, if a division instruction results in a float number, then the Carry Flag `CF` bit is turned on, or if a `sub` instruction resulted in a negative value, then the Sign Flag `SF` is turned on, and so on.

>Note: When `ZF` is on (i.e. is `1`), it's referred to as Zero `ZR`, and when it's off (i.e. is `0`), it's referred to as Not Zero `NZ`. This naming may match the condition code used in the instructions, like `jnz` which jumps with `NZ`. But to avoid any confusion, let's simply focus on the flag name.

There are many flags within an assembly program, and each of them has its own bit(s) in the `RFLAGS` register. The following table shows the different flags in the `RFLAGS` register:
![[Pasted image 20230711165257.png]]
![[Pasted image 20230711165244.png]]

Just like other registers, the 64-bit `RFLAGS` register has a 32-bit sub-register called `EFLAGS`, and a 16-bit sub-register called `FLAGS`, which holds the most significant flags we may encounter.

The flags we would mostly be interested in are:

- The Carry Flag `CF`: Indicates whether we have a float.
- The Parity Flag `PF`: Indicates whether a number is odd or even.
- The Zero Flag `ZF`: Indicates whether a number is zero.
- The Sign Flag `SF`: Indicates whether a register is negative.

All of the above flags are among the first few bits in the `FLAGS` sub-register. We will only be using the `jnz` instruction for our module project, which is applied whenever the `ZF` flag is equal to `0` (i.e., Not Zero `NZ`). 


## JNZ loopFib

The `loop loopFib` instruction we used in the last section is, in fact, a combination of two instructions: `dec rcx` and `jnz loopFib`, but since looping is a very common function, the `loop` instruction was created to reduce code size and be more efficient, instead of using both every time. However, the conditional jump instructions are much more versatile than `loop`, since they allow us to jump anywhere in the program on any condition we require.

Though it is more efficient to use `loop`, to demonstrate the use of `jnz`, let's go back to our code and try to use the `jnz` instruction instead of `loop`:
```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    dec rcx			; decrement rcx counter
    jnz loopFib		; jump to loopFib until rcx is 0
```

We see that we replaced `loop loopFib` with `dec rcx` and `jnz loopFib`, so that every time the loop reaches its end, the rcx counter would decrement by 1, and the program would jump back to `loopFib` if `ZF` is not set. Once `rcx` reaches `0`, the Zero Flag `ZF` would be turned on to `1`, and so `jnz` would no longer jump (since it's `NZ`), and we would exit the loop. Let's assemble our code, and run it with `gdb`, to see this in effect:
![[Pasted image 20230711165619.png]]

At each iteration of the loop, we are decreasing `rcx`, and the `zero` flag is off, while the `parity` flag is on when `rcx` is an odd number. The RFLAGS values at this point are set after the `dec rcx` instruction, as this is the last arithmetic instruction before we break. So, the flag states are for `rcx`.

Once `rcx` reaches `0`, the `zero` flag is set to on `1`, and `jnz` no longer jumps back to `loopFib`, the program stops executing.

>Note: `GEF` shows us the state of the flags in the `RFLAGS` register. The flags written in bold UPPERCASE letters are on.


## CMP

The Compare instruction `cmp` simply compares the two operands, by subtracting the second operand from first operand (i.e. `D1` - `S2`), and then sets the necessary flags in the `RFLAGS` register. For example, if we use `cmp rbx, 10`, then the compare instruction would do '`rbx - 10`', and set the flags based on the result.

- **cmp** - Sets `RFLAGS` by subtracting second from the first (i.e. first - second)
	- `cmp rax, rbx` -> `rax - rbx`

So, after the first Fibonacci number is calculated, it will do '`1 - 10`', and the result would be `-9`, so it will jump since it's a negative number `<0`. Once we reach the first Fibonacci number greater than `10`, which is `13` or `0xd`, it will do '`13 - 10`', and the result would be '`3`', at which case `js` would no longer jump, as the result is a positive number `>=0`.

We could use `sub` instructions to perform the same subtraction and set the flags if we wanted. However, this would not be efficient, as we will be changing the value of one of the registers, while the `cmp` only compares and does not store the result anywhere. `The main advantage of 'cmp' is that it does not affect the operands.`

>Note: In a `cmp` instruction, the first operand (i.e. the Destination) must be a register, while the other can be a register, a variable, or an immediate value.

So, let's change our code to use `cmp` and `js`, as follows:
```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
```

 Assemble our code, and run it with `gdb`, to see how this works. We will break at `loopFib`, and then step with `si` until we reach the `js loopFib` instruction:
  ![[Pasted image 20230711170110.png]]

 In the first iteration of `loopFib`, once we reach `js loopFib`, the `SIGN` flag is set to on `1` as expected, since the result of `1 - 10` is a negative number.  We also notice `GEF` telling us `TAKEN [Reason: S]`, which conveniently tells us that this conditional jump will be taken and gives the reason as `S`, meaning that the `SIGN` flag is set.

Let's take this opportunity to learn how to set conditional breakpoints in `gdb`.

Let's first delete the current breakpoint with `del 1`, and then set our conditional breakpoint. The syntax is very similar to setting regular breakpoints `b loopFib`, but we add an `if` condition after it, such as '`b loopFib if $rbx > 10`'. Also, instead of breaking at `loopFib` and then using `si` to reach `js`, let's directly break at `js` with `*` to refer to its location '`b *loopFib+9 if $rbx > 10`' or '`b *0x401012 if $rbx > 10`'.  
Remember: we can find an instruction's location with `disas loopFib`.

We see the following:
![[Pasted image 20230711170352.png]]

We see now that the last arithmetic instruction '`13 - 10`' resulted in a positive number, the `sign` flag is no longer set, so `GEF` tells us that this jump is `NOT TAKEN`, with the reason `!(S)`, meaning that the `sign` flag is not set.

As we can see, using conditional branching is very powerful and enables us to perform more advanced instructions based on a condition we specify. We can use the `cmp` instruction to test various conditions. For example, we can use `jl` instead of `jns`, which would jump as long as the Destination is Less than the Source. So, with `cmp rbx, 10`, `rbx` will start less than `10`, and once `rbx` gets greater than `10`, then `rbx` (i.e., the Destination) would be greater than `10`, at which point `jl` will not jump.

>Note: We may see instructions using JMP Equal `je`, or JMP Not Equal `jne`. This is just an alias of `jz` and `jnz`, since if both operands are equal, the outcome of `cmp rax, rax` would be `0` in all cases, which sets the Zero Flag. The same applies to `jge` and `jnl`, since `>=` is the same as `!`, and applies to other similar conditions as well.