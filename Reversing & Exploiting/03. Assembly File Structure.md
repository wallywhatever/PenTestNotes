
Let's start by taking a look at and dissecting a sample `Hello World!` Assembly code template:
``` nasm
         global  _start

         section .data
message: db      "Hello HTB Academy!"

         section .text
_start:
         mov     rax, 1
         mov     rdi, 1
         mov     rsi, message
         mov     rdx, 18
         syscall

         mov     rax, 60
         mov     rdi, 0
         syscall
```

This Assembly code (once assembled and linked) should print the string '`Hello HTB Academy!`' to the screen.

## Assembly File Structure

![[Pasted image 20230708223158.jpg|600]]

Looking at the vertical parts of the code, each line can have three elements: Labels, Instructions and Operands.

Looking at the code line by line, it has three main parts:
- `global _start`
	- This is a `directive` that directs the code to start executing at the `_start` label defined below.
- `section .data`
	- The data section that should contain all the variables.
- `section .text`
	- The text section containing all the code to be executed

# Directives

Fill this in more later but basically `global _start` tells the machine to start processing instructions after the `_start` label.


# Variables

- These are in the `.data` section. Once we run a program, all the variables are loaded into memory in this segment.
	- Notice that the `_start` label is after all the variables are loaded.
- The `.data` section is **read-write** but is not executable.
- We can define variables using `db` for a list of bytes, `dw` for a list of words, `dd` for a list of digits, and so on. 
	- We can also label any of our variables so we can call it or reference it later.

- The following are some examples of defining variables:
![[2023-07-08 22_38_28-Intro to Assembly Language.png|650]]

- We can use the `equ` instruction with the `$` token to evaluate an expression, like the length of a string. 
	- The labels defined with a `equ` instruction are constants.

 The following code defines a variable and then defines a constant for its length:
 ```nasm
section .data
    message db "Hello World!", 0x0a
    length  equ $-message
```

>Note: the `$` token indicates the current distance from the beginning of the current section. As the `message` variable is at the beginning of the `data` section, the current location, i.e,. value of `$`, equals the length of the string. For the scope of this module, we will only use this token to calculate lengths of strings, using the same line of code shown above.


## Code

- The most important section is `.text` which holds all the instructions and loads them into the `text` memory segment. 
- The default convention is to have the `_start` label at the beginning of the `.text` section
	- Other labels can be defined for loops and other functions.
- The `text` segment is **read-only**

>Tip: We can add comments to our assembly code with a semi-colon `;`. We can use comments to explain the purpose of each part of the code, and what each line is doing. Doing so will save us a lot of time in the future if we ever revisit the code and need to understand it.